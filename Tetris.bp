' Класический тетрис фигурки по 4 кубика падают в сетке gridX*gridY (задаем 8*8 пикселей) 12 клеток по горизонтали и 16 строк по вертикали.
' Получается все поле - массив N_X*N_Y = 12*16 = 192 клетки.
' Падающая фигурка только одна. Она реагирует на кнопки - влево ("L") - вправо ("R") и ускорение падения вниз ("D"),
' переворот влево - кнопка вверх ("U") (против часовой), переворот вправо ("E") (по часовой).
' Фигурка останавливается по достижению нижней границы или если нельзя втиснутся на нижнюю строку, так как там занята хотя бы одна клетка.
' При остановке фигурки она перестает быть единым целым, но вместо нее остаются занятые клетки в последней позиции на строках.
' При движении фигурки в текущие занимаемые ею клетки поля заносим признак занятости, смещая фигурку в новое состояние убираем признак занятости
' в клетках старой позиции и заносим признак занятости в клетки новой позиции.
' Если при смещении фигурки (падении, смещении влево-вправо, поворотах) в новой позиции хоть одна клетка занята, то смещения фигурки в новую
' позицию не происходит.
' При смещении вниз и невозможности сместить фигурку дальше - останавливаем фигурку, проверяем заполненность строк и, если есть заполненные строки
' убираем их построчно, смещая все верхние строки вниз. При этом ведем подсчет игровых очков по формуле U * H * N, где
' U - текущий игровой уровень задающий скорость, H - высота убираемой строки от дна, то есть нижняя строка 1, самая верхняя 16,
' N - номер одновременно убираемой строки (максимально можно убрать до 4 строк при сбросе фигуры номер 1 с вертикальной ориентацией)
' Снова запускаем новую фигурку. Такт падения фигурки задаем в переменной Takt.
' Увеличение скорости перемещения фигурок по времени при переходе из одного уровня игры в другой (просто уменьшаем переменную N_Takt).
'===================================================================================================================================================
import "LCDRu"      ' Руссификатор
import "Save"       ' Таблица рекордов
' Задаем игровое поле
N_kl        = 4    ' число занимаемых фигурой клеток
gX          = 8    ' ширина одной клетки поля (пока тоже 8 пикселей)
gY          = 8    ' высота одной клетки поля (8 пикселей)
N_Y         = 16   ' Количество строк в игровом поле высотой в одну клетку (gx = 8 пикселей)
N_X         = 12   ' Количесвто клеток в строке игрового поля
X_S         = 79   ' Смещение игрового поля относительно левой границы ЖКИ EV3
Pole        = Vector.Init(N_Y*N_X, 0)        'создаем пустое игровое поле
' Задаем параметры падающей фигурки
N_Fig       = 7    ' Число типов фигур
Wf          = 8    ' ширина одного кубика (8 пикселей)
Hf          = 8    ' высота одного кубика (8 пикселей)
Type        = 0    ' Тип фигуры 1 - ████████, 2 - ██████, 3 - ██████, 4 - ██████, 5 - ████, 6 - ████ , 7 -   ████
'                                                 ██            ██            ██      ████        ████     ████
'                               1 - 1234,     2 - 123,    3 - 123,    4 - 123,    5 - 12,   6 - 12 ,   7 -  34
'                                                 4            4            4         43         34        12
Direct      = 0  ' Ориентация фигуры 0 - вправо, 1 - вниз, 2 - влево, 3 - вверх
Type_Next   = 0  ' Тип следующей фигуры
Direct_Next = 0  ' и ее ориентация - для показа в поле next на ЖКИ
Xf          = 0  ' Текущие координаты 1-го кубика фигуры
Yf          = 0  ' координаты других кубиков вычисляются в зависимости от типа и поворота фигуры
dX2         = 0  ' смещение для 2-го,
dY2         = 0  '
dX3         = 0  '3-го и
dY3         = 0  '
dX4         = 0  '4-го кубиков фигуры относительно 1-го кубика
dY4         = 0  '
' Задаем параметры игры
tick        = 20      ' Программный тик - 50 мс - для подсчета времени одного хода (такта)
N_Takt      = 50      ' Число тиков tick в такте падения фигуры. Начинаем с 50 (то есть 1 секунда) - потом уменьшаем, для убыстрения падения
takt        = 0       ' счетчик тактов
N_btn       = 30      ' Задержка первого повтора кнопки при постоянном нажатии
btn_rep     = 0       ' После отработки первой паузы после нажатия кнопки включаем быстрый повтор
N_povtor    = 10      ' При нажатой кнопке повтор нажатия после первой задержки через N_povtor тиков
takt_povtor = 0       ' счетчик подсчета тактов до повтора выдачи кода нажатой кнопки
Count       = 0       ' счётчик игровых очков (учитывается уровень, высота строки от дна, одновременность удаления строк)
TimeGame    = 0       ' Условное время игры в тактах takt
Uroven      = 1       ' Уровень скорости игры, чем больше - тем больше скорость ( а также тем больше очков за убранную строку кубиков)
Sound       = 1       ' Выдавать звуковые сигналы - 1 - "Y" - да, 0 - "N" - нет
SetNext     = "Y"     ' Отображать следующую фигурку в окошечке - "Y" - да, "N" - нет
IsRun       = 4       ' признак запуска игры 0 - завершение игры, 1 - игра запущена, 2 - повтор игры текущим игроком,
                      ' 3 - повтор игры с заданием нового игрока, 4 - запуск с начального экрана приветствия
IsFigDrop   = 0       ' признак, что фигуры на поле нет, то есть она достигла своей нижний позиции и остановлена
IsStop      = 0       ' признак срочного выхода из игры в режиме пауза игры (по одновременному нажатию  [E] и [R]) 
'----------------------------------------------
' Считываем и инициализируем текущую таблицу рекордов и задаем ей имя
Save.ReadTableRec("TetrisRecords", "   NF<KBWF HTRJHLJD   ")  ' ТАБЛИЦА РЕКОРДОВ
EV3.SetLEDColor("OFF", "NORMAL")              ' Гасим светодиоды, а то отвлекают
Speaker.Play(30, "Hello")                     ' Озвучиваем приветствие
StartGame()                                   ' первый запуск - с приветственного экрана
'==================================================================================================================================================
While IsRun = 1                               ' Игровой цикл в один тик
  If IsFigDrop = 0 And takt = 0 Or IsStop = 1 Then ' Вначале такта, если текущей фигурки нет на поле (или если вышли из паузы), то
    If IsStop = 0 Then                        ' Если это не экстреный выход из игры, то просто продолжаем игру
      CreateFig(Res)                          ' задаем новую фигуру и выводим ее на игровое поле в верхних строках
      IsFigDrop = 1                           ' ставим признак, что фигура на поле
    EndIf                                     '  
    If Res = 0 Or IsStop = 1 Then             ' Если выставить ее на поле не удалось, значит игра закончена
      StopGame()                              ' Выполняем действия по завершению игры (но выход на конец игры будет в самой функции по Programm.End())
      StartGame()                             ' Выполняем действие для повторного старта.
      CreateFig(Res)                          ' задаем первую фигуру для повторной игры и выводим ее на игровое поле в верхних строках
    EndIf
  EndIf
  ' А теперь наша реакция на нажатые в игровом цикле кнопки
  btn = Buttons.Current
  If btn <> "U" And btn <>"D" And btn <> "L" And btn <> "R" And btn <> "E" Then
    BtnOld = "_"            ' признак что ничего не нажато, главное чтобы отличалось от Buttons.Current - при ненажатой кнопке
  ElseIf BtnOld <> btn Then ' Если кнопка только что нажата, то
    BtnOld = btn            ' запоминаем ее, чтобы реагировать на нажатие кнопки один раз
    takt_povtor = 0         ' Сработает как только будет нажата кнопка
    btn_rep = 0             ' ждем первого повтора - то есть начнем отсчет паузу (до N_btn) - то есть до певого повтора
  EndIf
  If btn = BtnOld Then                                ' Реагируем только на нажатую кнопку и удержание нажатой кнопки
    If takt_povtor = 0 Then                           ' Пора сделать действие по нажатой кнопке?
      If btn = "L" Or btn = "R" Or btn = "D" Then
        Move(btn, Res)                                ' перемещение влево-вправо
      ElseIf btn = "U" Then                           ' Пауза в игре
        LCDRu.TextRu (1, 1, 23, 2, "cnjg" )           ' сообщаем про паузу на экране
        Buttons.Flush()                               ' просто делаем паузу в игре
        btn1 = ""                                     ' Во время паузы можно увеличить уровень и включить/выключить звуковые сигналы
        While btn1 <> "E"                             ' Выход из паузы по нажатию "E"
          Buttons.Wait()                              ' до любой нажатой кнопки
          btn1 = Buttons.GetClicks()                  ' Считали нажатую кнопку -           '
          If btn1 = "U" Then                          ' выполнили заданное действие
            If Uroven < 16 Then
              Uroven = Uroven + 1                     ' увеличиваем уровень от 1 до 16
              N_Takt = N_Takt - 3                     ' уменьгаем время условного такта
              LCD.Text (1, 48, 112,  1, ":" + Uroven) ' отображаем новый уровень по скорости
            EndIf
            ' ElseIf btn1 = "D" Then                    ' а фигушки - уменьшать уровень во время игры - хотя, кто хочет - может раскомментарить
            '   If @Uroven > 1 Then                     '
            ' Uroven = Uroven - 1                       ' уменьшаем уровень от 16 до 1
            ' N_Takt = N_Takt + 3                       ' увеличиваем время условного такта
            'EndIf                                      '
          ElseIf btn1 = "L" Then                      ' Включаем/выключаем звуковые сигналы
            If Sound = 1 Then                         '
              Sound = 0                               ' выключили звук
            Else                                      '
              Sound = 1                               ' включили звук
            EndIf                                     '    
          ElseIf btn1 = "R" Then                      ' Включаем/выключаем отображение следующей фигурки
            If SetNext = "Y" Then                    '
              SetNext = "N"                           ' выключили отображение
            Else                                      '
              SetNext = "Y"                           ' включили отображение
            EndIf                                     '    
          ElseIf btn1 = "ER" Then                     ' одновременное надатие [E] и [R]
            IsRun = 0                                 ' закончить игру
            break                                     '
          EndIf                                       '
        EndWhile
        LCD.Text (1, 1, 23, 2, "    " )               ' убираем слово пауза с экрана
        LCD.Text (1, 20 , 23 , 2 , Count )            ' и восстанавливаем отображение текущего счета
      ElseIf btn = "E" Then
        Rotate(btn, Res)                              ' вращение по часовой стрелке
        btn_rep = 0                                   ' повтор ограничиваем паузой до выдачи первого кода
        If Res = 11 Or Res = 12 Or Res = 13 Then      ' Повернуть нельзя из-за выхода за верхнюю границу
          Move("D", Res)                              ' Смещаемся вниз на одну клетку
          If Res = 1 Then                             ' Если это удалось, то
            Rotate(btn, Res)                          ' опять пробуем повернуть
          EndIf
        ElseIf Res = 21 Or Res = 22 Or Res = 23 Then  ' Повернуть нельзя из-за выхода за левую границу
          Move("R", Res)                              ' Смещаемся вправо на одну клетку
          If Res = 1 Then                             ' Если это удалось, то
            Rotate(btn, Res)                          ' опять пробуем повернуть
          EndIf
        ElseIf Res = 31 Or Res = 32 Or Res = 33 Then  ' Повернуть нельзя из-за выхода за правую границу
          Move("L", Res)                              ' Смещаемся влево на одну клетку
          If Res = 1 Then                             ' Если это удалось, то
            Rotate(btn, Res)                          ' опять пробуем повернуть
          EndIf
        EndIf
      EndIf
      If btn = "D" And btn_rep = 1  Then              ' При удержании кнопки вниз - после первоначальной задержки
        '                                               ускоренно сбрасываем фигуру вниз, то есть не отсчитываем паузу для повтора
        While Res = 1                                 ' Пока возможно сбрасывать фигуру вниз сбрасываем
          Move("D", Res)                              ' Смещаемся вниз на одну клетку
        EndWhile
        Program.Delay(100)                            ' небольша задержка, чтобы следующая фигура не сбрасывалась вслед за текущей
      Else
        takt_povtor = 1                               ' для всех остальных (особенно для первого кода - начинаем отсчет паузы с 1)
      EndIf
      If Res = 1 Then                                 ' если действие по кнопке выполнено
        EV3.SetLEDColor("GREEN", "NORMAL")            ' то мигаем зеленым светодиодом
      Else
        EV3.SetLEDColor("RED", "NORMAL")              ' иначе мигаем красным светодиодом
      EndIf
      Program.Delay(50)
      EV3.SetLEDColor("OFF", "NORMAL")
    Else                                              ' при удерживании нажатой кнопки -
      takt_povtor = takt_povtor + 1                   ' подсчитываем паузы для повтора
      If takt_povtor = N_btn And btn_rep = 0 Then     ' пауза для первой выдачи кода нажатой кнопки после продолжительного нажатия?
        btn_rep = 1                                   ' ждем последующих повторов после первого
        takt_povtor = 0                               ' признак выдать код нажатой кнопки - для выполнения действий по нему
      EndIf
      If takt_povtor = N_povtor And btn_rep = 1 Then  ' последующие выдачи кода постоянно нажатой кнопки
        takt_povtor = 0                               ' признак выдать код нажатой кнопки - для выполнения действий по нему
      EndIf
    EndIf
  EndIf
  Program.Delay(tick)                                 ' Задержка в один тик (задает темп нажатия кнопок, то есть реакцию игрока)
  takt = takt + 1                                     ' Подсчитываем один условный такт программы
  If takt = N_Takt Then                               ' (темп падения фигурок)
    Move("D", Res)                                    ' фигура падает вниз на одну строку
    takt = 0                                          '
    TimeGame = TimeGame + 1                           ' Текущее время игры в тактах
    LCD.Text (1, 8, 112, 1, TimeGame)                 ' отображаем на экране,
    LCD.Text (1, 48, 112, 1, ":" + Uroven)            ' а также текущий уровень по скорости
    ' Для постепенного увеличения скорости игры уменьшаем время такта падения фигуры в тиках
    If Math.Remainder(TimeGame, 100) = 0 Then         ' в каждом 100-ом такте игры
      If Uroven <= 16 Then
        Uroven = Uroven + 1                           ' увеличиваем уровень от 1 до 16
        N_Takt = N_Takt - 3                           ' уменьшаем время такта
      EndIf
    EndIf
    If Res = 0 Or Res >= 40 Then                      ' Если фигура не может провалиться ниже на строку, так как клетки на нижней строке заняты,
      IsFigDrop = 0                                   ' или достигла нижней строки, то оставляем ее там, где она приземлилась и ставим признак фигуры нет
      Count = Count + Uroven                          ' За каждую выведенную и остановленную на поле фигурку начисляем очки в размере номера уровня
      DrawCount(Count)                                ' прорисовываем счет на поле
      Check()                                         ' Проверяем не надо ли убрать заполненную строку (строки), а также подсчитываем игровые очки
      Speaker.Play(20*Sound, "Drop load")             ' Озвучиваем остановку фигуры
      Program.Delay(50)                               ' маленькая задержка
    EndIf
  EndIf
EndWhile

'==================================================================================================================================================
' признак запуска игры 0 - завершение игры, 1 - игра запущена, 2 - повтор игры текущим игроком,
' 3 - повтор игры с заданием нового игрока, 4 - запуск с начального экрана приветсви
Function StartGame()                          ' Действия при старте игры
  While @IsRun = 4                            ' Мы в начальном экране? Циклим в нем
    DrawLCDStart()                            ' Выводим приветсвенное начальное меню
    Buttons.Wait()                            ' ждем ответа игрока
    btn = Buttons.GetClicks()                 '
    If     btn = "E" Then                     ' Нажата "E" - команда запуска,
      If Save.TekNum = 0 Then                 ' но если игрок не задан, то
        @IsRun = 3                            ' задаем признак - надо задать имя текущего игрока
      Else                                    ' а если игрок установлен -
        @IsRun = 2                            ' то задаем признак - запуска игры с текущим игроком
      EndIf
    ElseIf btn = "U" Then                     ' Нажата "U" - помощь по кнопкам управления,
      DrawLCDUpr()                            ' Выводим экран помощи
    ElseIf btn = "L" Then                     ' Нажата "L" - помощь по кнопкам управления таблицей рекордов,
      Save.DrawLCDHelpTabl()                  ' просто выводим экран помощи из модуля таблицы рекордов.
    ElseIf btn = "R" Then                     ' Нажата "R" - ввод имени текущего игрока,
      Save.TekStr = Save.TekLen + 1           ' Становимся на первую пустую строку с приглашением "новый игрок"
      @IsRun = 3                              ' задаем признак - задать имя текущего игрока
    ElseIf btn = "D" Then                     ' Нажата "D" - выход из программы,
      @IsRun = 0                              '
      Program.End()                           ' то немедленно напрямую завершаем программу.
      'Goto End_Game                           ' то немедленно напрямую завершаем программу.
    EndIf
  EndWhile                                    '
  '-------------------------------------------
  If @IsRun = 3 Then                          ' Задано задать нового текущего игрока
    Save.PrintTableRec(1)                     ' Распечатываем текущую таблицу рекордов с возможностью выбора игрока при этом задаются параметры игрока
    ' в свойствах объекта Save - [TekNum, TekName, TekCount и TekUroven и даже TekParol]
    @IsRun = 2                                ' задаем продолжить запуск игры с текущим игроком
  EndIf                                       '
  '-------------------------------------------
  If @IsRun = 2 Then                          ' Задано запустить игру с текущим игроком
    DrawLCDGamer()                            ' Выводим экран с приветсвием игроку
    @IsRun = 1                               ' и задаем признак запустить игру
  EndIf                                       '
  '-------------------------------------------  к этому моменту признак @IsRun должен быть равен 1
  DrawLCDNastr()                              ' Выводим экран предварительных настроек
  '-------------------------------------------
  ' Настройки выполнены - запускаем или перезапускаем игру
  Speaker.Play(30, "Start")                   ' Озвучиваем
  @Count = 0                                  ' сбросвыаем текущий счет
  Program.Delay(1000)                         ' маленькая задержка
  Draw_Pole()                                 ' инициализируем массив клеток поля, очищаем его и рисуем поле
  @IsStop = 0                                 ' сбрасываем признак экстренного выхода  
EndFunction
'==================================================================================================================================================
' Вывод на экран ЖКИ EV3 приветственного экран игры тетрис
Function DrawLCDStart()                                  '
  LCD.StopUpdate()                                       ' выводим весь экран сразу
  LCD.Clear()                                            ' Очистили экран
  LCD.FillRect(1,   0,    0, 176,   26)                  ' рамка вокруг названия игры
  LCD.FillRect(0,   19,   2, 136,   20)                  '
  LCDRu.TextRu(1,   38,   4, 2, "NTNHBC")                ' Вывод заголовка приветственного экрана "ТЕТРИС"
  '                                                      1231467890123456789012
  LCDRu.TextRu(1,   0,   27, 2, "/aU")                   'U - УПРАВЛЕНИЕ ИГРОЙ
  LCDRu.TextRu(1,  20,   32, 1, "- EGHFDKTYBT BUHJQ")    '
  LCDRu.TextRu(1,   0,   47, 2, "/aL")                   'L - УПРАВЛЕНИЕ ТАБЛ.
  LCDRu.TextRu(1,  20,   52, 1, "- EGHFDKTYBT NF<K/a.")  '
  LCDRu.TextRu(1,   0,   67, 2, "/aE")                   'E - ЗАПУСК ИГРЫ
  LCDRu.TextRu(1,  20,   72, 1, "- PFGECR BUHS")         '
  LCDRu.TextRu(1,   0,   87, 2, "/aR")                   'R - НОВЫЙ ИГРОК
  LCDRu.TextRu(1,  20,   92, 1, "- YJDSQ BUHJR")         '
  LCDRu.TextRu(1,   0,  107, 2, "/aD")                   'D - ВЫХОД ИЗ ИГРЫ
  LCDRu.TextRu(1,  20,  112, 1, "- DS{JL BP BUHS")       '
  LCD.Update()                                           ' Выводим сразу всю картинку
  ' реакцию игрока обрабатываем в вызывающей программе
EndFunction
'---------------------------------------------------------------------------
' Вывод на экран ЖКИ EV3 информации о кнопках управления игрой тетрис
Function DrawLCDUpr()                                    '
  LCD.StopUpdate()                                       ' выводим весь экран сразу
  LCD.Clear()                                            ' Очистили экран
  LCDRu.TextRu(1,  0,   5, 2, "EGHFDKTYBT")              ' заголовок "УПРАВЛНИЕ"
  LCD.Rect(1, 128,  36, 24, 24)                          ' рисуем клавиатуру
  LCD.Rect(1, 130,  38, 20, 20)                          ' с двойной рамкой
  LCD.Text(1, 132,  40, 2, "U")                          '
  LCD.Rect(1, 104,  60, 24, 24)                          '            U
  LCD.Rect(1, 106,  62, 20, 20)                          '          L E R
  LCD.Text(1, 108,  64, 2, "L")                          '            D
  LCD.Rect(1, 128,  60, 24, 24)                          '
  LCD.Rect(1, 130,  62, 20, 20)                          '
  LCD.Text(1, 132,  64, 2, "E")                          '
  LCD.Rect(1, 152,  60, 24, 24)                          '
  LCD.Rect(1, 154,  62, 20, 20)                          '
  LCD.Text(1, 156,  64, 2, "R")                          '
  LCD.Rect(1, 128,  84, 24, 24)                          '
  LCD.Rect(1, 130,  86, 20, 20)                          '
  LCD.Text(1, 132,  88, 2, "D")                          '
  LCDRu.TextRu(1,   0,   30, 2, "/aU")                   'U - ПАУЗА
  LCDRu.TextRu(1,  20,   35, 1, "- GFEPF")               '
  LCDRu.TextRu(1,   0,   50, 2, "/aL")                   'L - ВЛЕВО
  LCDRu.TextRu(1,  20,   55, 1, "- DKTDJ")               '
  LCDRu.TextRu(1,   0,   70, 2, "/aE")                   'E - ВРАЩЕНИЕ
  LCDRu.TextRu(1,  20,   75, 1, "- DHFOTYBT")            '
  LCDRu.TextRu(1,   0,   90, 2, "/aR")                   'R - ВПРАВО
  LCDRu.TextRu(1,  20,   95, 1, "- DGHFDJ")              '
  LCDRu.TextRu(1,   0 , 110, 2, "/aD")                   'D - ВНИЗ и СБРОС
  LCDRu.TextRu(1,  20 , 115, 1, "- DYBP b C<HJC")        '
  LCD.Update()                                           ' Выводим сразу всю картинку
  Buttons.Wait()                                         ' по нажатию на любую кнопку
  Buttons.Flush()                                        ' выходим из показа экрана
EndFunction
'---------------------------------------------------------------------------
' Вывод на экран ЖКИ EV3 приветственной информации о текущем игроке.
' Показывает сообщение "ПРИВЕТ", а потом имя игрока, его место в таблице рекордов и выбранный рекорд и уровень
' предшествует настроечному экрану игры Тетрис
Function DrawLCDGamer()                                  '
  LCD.StopUpdate()           '12345678901
  LCD.Clear()                                            '
  LCDRu.TextRu(1, 10, 16, 2, "  GHBDTN   ")              '   ПРИВЕТ
  LCDRu.TextRu(1,  0, 40, 2, Save.TekName)               ' ИМЯ ИГРОКА
  Save.NumToStrRight(Save.TekNum, 2, StrNum)             'выравниваем на правую границу
  LCDRu.TextRu(1, 0,  64, 2, "YJVTH -  "  + StrNum)      'его место (максимальное) в таблице рекордов
  Save.NumToStrRight(Save.TekCount, 7, StrCount)         'выравниваем на правую границу
  LCDRu.TextRu(1, 0,  88, 2, "CX~N"       + StrCount)    'его рекорд в очках
  Save.NumToStrRight(Save.TekUroven, 2, StrUroven)       'выравниваем на правую границу
  LCDRu.TextRu(1, 0, 112, 2, "EHJDTYM/a: " + StrUroven)  'достигнутый уровень
  LCD.Update()                                           ' Для быстрой прорисовки
  Buttons.Wait()                                         ' по нажатию на любую кнопку
  Buttons.Flush()                                        ' выходим из показа экрана
EndFunction
'---------------------------------------------------------------------------
' Вывод на экран ЖКИ EV3 настроечного меню игры тетрис.
' Позволяет выбрать начальный уровень (скорость), включить/выключить звук, включить/выкдлючить подсказку следующей фигурки
Function DrawLCDNastr()
  btn = ""
  If @Sound = 1 Then          ' Настройку звука - сохраняем предыдущую
    SetSound = "Y"
  Else
    SetSound = "N"
  EndIf
  If @Uroven > 9 Then         ' А вот предыдущий уровень сбрасываем до 9, если он был двузначный
    @Uroven = 9
  EndIf
  ' Цикл настроек - можем задать начальный уровень, а также воспроизводить или нет звуковые эффекты
  LCD.StopUpdate()
  LCD.Clear()
  LCDRu.TextRu(1, 00, 20, 2, "CNFHN/a-[E]")     '
  LCD.Line(1, 141, 48, 153, 37)     '
  LCD.Line(1, 153, 37, 165, 48)     '
  LCD.Line(1, 141, 48, 165, 48)     '
  LCDRu.TextRu(1, 0,  50, 2, "EHJDTYM/a-[" + @Uroven + "]")
  LCD.Line(1, 141, 68, 153, 79)     '
  LCD.Line(1, 153, 79, 165, 68)     '
  LCD.Line(1, 141, 67, 165, 68)     '
  LCDRu.TextRu(1, 0,  85, 2, "PDER /a-  <" + SetSound + ">")
  '1234  567890  123456789012
  LCDRu.TextRu(1, 0, 110, 1, "DSRK - /a[L], /rDRK -/a[R]")     '
  LCD.Update()                ' Для быстрой прорисовки
  While btn <> "E"
    Buttons.Wait()                            '
    btn = Buttons.GetClicks()                            '
    If btn = "U" Then
      If @Uroven < 9 Then
        @Uroven = @Uroven + 1   ' увеличиваем уровень от 1 до 16
        @N_Takt = @N_Takt - 3   ' ументшаем время условного такта
      EndIf
    ElseIf btn = "D" Then
      If @Uroven > 1 Then
        @Uroven = @Uroven - 1   ' уменьшаем уровень от 16 до 1
        @N_Takt = @N_Takt + 3   ' увеличиваем время условного такта
      EndIf
    ElseIf btn = "L" Then       ' По кнопке "L"
      If @Sound = 1 Then        ' переключаем разрешение звуковых сигналов
        @Sound = 0              ' запрещаем выдачу звуковых сигналов
        SetSound = "N"          '
      Else                      '
        @Sound = 1              ' разрещаем выдачу звуковых сигналов
        SetSound = "Y"          '
      EndIf  
    ElseIf btn = "R" Then       ' По кнопке "R"
      If @SetNext = "Y" Then    '
         @SetNext = "N"         ' Запрещаем отображать следующую фигуру
      Else                       
         @SetNext = "Y"         ' Разрешаем отображать следующую фигуру
      EndIf
    EndIf
    LCDRu.TextRu(1, 144,  50, 2, "" + @Uroven)
    LCDRu.TextRu(1, 144,  85, 2, "/a" + SetSound)
  EndWhile
EndFunction
'==================================================================================================================================================
Function StopGame()                                  ' Действия при окончании игры
  '-------------------------------------------
  LCD.StopUpdate()
  LCD.Clear( )                                       ' Выводим сообщение об окончании игры
  LCDRu.TextRu(1, 0, 16, 2, "RJYTW BUHS")            ' на экран "КОНЕЦ ИГРЫ"
  Speaker.Play(30, "Game over")                      ' Озвучиваем
  Save.NumToStrRight(@Uroven, 2, StrUroven)          ' выравниваем на правую границу его текущий уровень
  LCDRu.TextRu(1, 0, 40, 2, "EHJDTYM  " + StrUroven)'  Выводим уровень до которого добрался игрок
  Save.NumToStrRight(@Count, 7, StrCount)            ' выравниваем на правую границу его рекорд
  LCDRu.TextRu(1, 0, 64, 2, "CX~N" + StrCount)       ' и выводим
  LCD.Update()                                       ' Для быстрой прорисовки
  ' проверка попадания в таблицу рекордов
  Save.PushTableRec(@Count, @Uroven, IsRecord)       ' Записываем рекорд в таблицу рекордов, если конечно он есть
  Buttons.Flush()                                    ' сбрасываем нажатые кнопки
  If IsRecord = 1 Then                               ' Если есть рекорд, то
    LCDRu.TextRu(1, 0, 84, 2, "|NJ HTRJHL")          ' Пишем ЭТО РЕКОРД
    Save.NumToStrRight(Save.TekNum, 2, StrNum)       ' выравниваем на правую границу
    LCDRu.TextRu(1, 0, 104, 2, "VTCNJ #/a: "+ StrNum)' указываем место в таблице рекордов
    Buttons.Wait()                                  '  ждем ответа игрока
    Save.PrintTableRec(0)                           '  и выводим новую таблицу рекордов, чтобы он на нее полюбовался.
  Else
    Buttons.Wait()                                  ' Если рекорда нет - то просто ждем ответа твета игрока
  EndIf                                             ' для просмотра текущего счета на ЖКИ
  Buttons.Flush()                                   ' так как ждали нажатия кнопки, то сбрасываем код нажатой кнопки
  LCD.StopUpdate()
  LCD.Clear()
  '                             12345678901        Задаем меню выбора действий по окончанию игры
  LCDRu.TextRu(1,  0, 20, 2, "/a[U]-")              ' [U]-
  LCDRu.TextRu(1, 64, 10, 2,        " YJDSQ")       '  НОВЫЙ
  LCDRu.TextRu(1, 64, 30, 2,        " BUHJR")       '  ИГРОК
  LCDRu.TextRu(1,  0, 60, 2, "/a[E]-")              ' [E]-
  LCDRu.TextRu(1, 64, 50, 2,        " GJDNJH")      ' ПОВТОР
  LCDRu.TextRu(1, 64, 70, 2,        " BUHS")        ' ИГРЫ
  LCDRu.TextRu(1,  0,100, 2, "/a[D]-/r DS{JL")      ' [D]- ВЫХОД
  LCD.Update()
  Buttons.Wait()                                    ' ждем ответа игрока
  btn = Buttons.GetClicks()                         ' Считали ответ игрока
  If btn = "E" Then                                 ' запустить новую игру? (с прежним игроком)
    If IsRecord = 1 Then                            ' если был рекорд
      @IsRun = 2                                    ' то - запускаем с экраном "Привет" игроку, так как у него новый рекорд
    Else                                            ' а если рекорда нет, то значит ничего не поменялось
      @IsRun = 1                                    ' то - запускаем без повторного Привета игроку
    EndIf                                           '
  ElseIf btn = "U" Then                             ' запустить новую игру и поменять игрока?
    Save.TekNum = Save.TekLen + 1                   ' Становимся на первую пустую строку с приглашением "новый игрок"
    @IsRun = 3                                      ' и запускаем с изменением текущего игрока
  Else                                              ' иначе - прощаемся
    @IsRun = 0                                      ' Для выхода из игрового цикла
    LCD.StopUpdate()
    LCD.Clear()                                     ' выводим
    LCDRu.TextRu(1, 20, 20, 2, "GJRF-GJRF")         ' прощальное сообщение ПОКА-ПОКА
    LCDRu.TextRu(1, 10, 45, 2, "LJ DCNHTXB")        ' ДО ВСТРЕЧИ
    LCD.Update()
    Speaker.Play(30, "Goodbye")                     ' и озвучиваем его
    Program.Delay(3000)                             ' время на посмотреть на сообщение
    Program.End()                                   ' немедленно напрямую завершаем программу.
    'Goto End_Game                                   ' Прямо выходим из программы.
  EndIf
EndFunction

'--------------------------------------------------------------------------------------------------------------------------------------------------
Function Draw_Pole()
  LCD.StopUpdate()
  LCD.Clear()
  @Pole = Vector.Init(@N_Y*@N_X, 0)         'очищаем игровое поле
  LCDRu.TextRu (1,  5,   0,  1, " NTNHBC ") ' ТЕТРИС
  LCD.Rect (1,  0,  17, 72, 26)             '
  LCDRu.TextRu (1, 15,  13,  1, "cx`n ")    ' заголовок "счёт"
  LCD.Text (1, 20,  23,  2, @Count)         'отображаем текущий счет
  LCD.Rect (1,  0,  54, 72, 53)             '
  LCDRu.TextRu (1, 15,  48,  1, " cktl ")   '
  LCD.Rect (1,  0, 110, 72, 12)             '
  LCD.Text (1,  8, 112,  1, @TimeGame)      ' отображаем текущее условное время игры
  LCD.Text (1, 48, 112,  1, ":" + @Uroven)  ' а также текущий уровень по скорости
  LCD.Update()
  ' Для постепенного увеличения скорости игры уменьшаем время такта падения фигуры в тиках
  setka()
  Next()
EndFunction
'--------------------------------------------------------------------------------------------------------------------------------------------------
Function Next()
  @Type_Next   = Math.GetRandomNumber(@N_Fig) ' Задаем фигуре случайный тип
  @Direct_Next = Math.GetRandomNumber(4) - 1  ' и случайную ориентацию
  ' Строим фигуру по типу и повороту, т.е. вычисляем смещения dX и dY для 2,3,4 кубиков относительно 1 кубика
  GetFig(@Type_Next, @Direct_Next, X1, Y1, dX2, dY2, dX3, dY3, dX4, dY4)
  ' выводим ее в поле next
  If @SetNext = "Y" Then                                            ' Если задано отображать, то 
    LCD.FillRect (0, 1, 58, 70, 48)                                   ' стираем прежнюю фигуру
    LCD.FillRect(1, 24+(X1+ 0 )*@gX, 68 + (Y1+ 0 )*@gY, @Wf, @Hf)     ' и выводим новую
    LCD.FillRect(1, 24+(X1+dX2)*@gX, 68 + (Y1+dY2)*@gY, @Wf, @Hf)
    LCD.FillRect(1, 24+(X1+dX3)*@gX, 68 + (Y1+dY3)*@gY, @Wf, @Hf)
    LCD.FillRect(1, 24+(X1+dX4)*@gX, 68 + (Y1+dY4)*@gY, @Wf, @Hf)
  EndIf
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
Function Setka()
  For i = 0 To @N_X
    LCD.Line(1, @X_S + i*@gX, 0, @X_S + i*@gX, 128)
  EndFor
  For j = 0 To @N_Y-1
    LCD.Line(1, @X_S, j*@gY, 176, j*@gY)
  EndFor
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
Function Draw()
  LCD.FillRect(1, @X_S+(@Xf+ 0  )*@gX, (@Yf+ 0  )*@gY, @Wf, @Hf)
  LCD.FillRect(1, @X_S+(@Xf+@dX2)*@gX, (@Yf+@dY2)*@gY, @Wf, @Hf)
  LCD.FillRect(1, @X_S+(@Xf+@dX3)*@gX, (@Yf+@dY3)*@gY, @Wf, @Hf)
  LCD.FillRect(1, @X_S+(@Xf+@dX4)*@gX, (@Yf+@dY4)*@gY, @Wf, @Hf)
  ' ставим признаки занятия кубиками фигуры клеток игрового поля
  @Pole[(@Yf +  0  ) * @N_X + (@Xf +  0  )] = 1
  @Pole[(@Yf + @dY2) * @N_X + (@Xf + @dX2)] = 1
  @Pole[(@Yf + @dY3) * @N_X + (@Xf + @dX3)] = 1
  @Pole[(@Yf + @dY4) * @N_X + (@Xf + @dX4)] = 1
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
Function Clear()
  LCD.FillRect(0, @X_S+(@Xf+ 0  )*@gX, (@Yf+ 0  )*@gY, @Wf, @Hf)
  LCD.Rect(1, @X_S+(@Xf+ 0  )*@gX, (@Yf+ 0  )*@gY, @Wf+1, @Hf+1)        ' чтобы не стирать линии сетки
  LCD.FillRect(0, @X_S+(@Xf+@dX2)*@gX, (@Yf+@dY2)*@gY, @Wf, @Hf)
  LCD.Rect(1, @X_S+(@Xf+@dX2)*@gX, (@Yf+@dY2)*@gY, @Wf+1, @Hf+1)
  LCD.FillRect(0, @X_S+(@Xf+@dX3)*@gX, (@Yf+@dY3)*@gY, @Wf, @Hf)
  LCD.Rect(1, @X_S+(@Xf+@dX3)*@gX, (@Yf+@dY3)*@gY, @Wf+1, @Hf+1)
  LCD.FillRect(0, @X_S+(@Xf+@dX4)*@gX, (@Yf+@dY4)*@gY, @Wf, @Hf)
  LCD.Rect(1, @X_S+(@Xf+@dX4)*@gX, (@Yf+@dY4)*@gY, @Wf+1, @Hf+1)
  ' освобождаем клетки игрового поля
  @Pole[(@Yf +  0  ) * @N_X + (@Xf +  0  )] = 0
  @Pole[(@Yf + @dY2) * @N_X + (@Xf + @dX2)] = 0
  @Pole[(@Yf + @dY3) * @N_X + (@Xf + @dX3)] = 0
  @Pole[(@Yf + @dY4) * @N_X + (@Xf + @dX4)] = 0
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
Function Check()
  n_str = 0                             ' счетчик убираемых строк. За одновременно убираемые строки добавляем очки
  For j = 0 To @N_Y-1                   ' Начинаем с самой верхней строки
    PrFill = 1                          ' Задаем признак, что строка заполнена
    For i = 0 To @N_X-1                 ' Для всех клеток строки проверяем, что они заполнены, т.е. содержат 1
      If @Pole[j * @N_X + i] = 0 Then
        PrFill = 0                      ' Если хотя бы одна клетка в строке пустая (0), то сбрасываем признак, что строка заполнена
      EndIf
    EndFor
    ' проверяем надо ли убрать строку, если она заполнена
    If PrFill = 1 Then
      n_str = n_str + 1                  ' количество убираемых строк
      DropStroka(j, n_str)               ' Удаляем текущую заполненную строку ( за каждую следуюшую одновременно убираемую строку увеличиваем очки)
    EndIf
  EndFor
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
Function DropStroka(in number Nstr, in number n_str)
  LCD.StopUpdate()                                          ' для ускорения блокируем пока прорисовку на экран
  For j = Nstr-1 To 0 Step -1
    For i = 0 To @N_X-1
      @Pole[(j+1) * @N_X + i] = @Pole[j * @N_X + i]         ' просто последовательно переписываем признак занятости клетки в нижнюю строку
      If @Pole[j * @N_X + i] = 1 Then                       ' и перерисоваваем клетки на поле
        LCD.FillRect(1, @X_S + i*@gX, j*@gY, @Wf, @Hf)      ' заполненная клетка
      Else
        LCD.FillRect(0, @X_S + i*@gX, (j+1)*@gY, @Wf, @Hf)  ' пустая клетка
        LCD.Rect(1, @X_S + i*@gX, (j+1)*@gY, @Wf+1, @Hf+1)  ' но линии сетки оставляем
      EndIf
    EndFor
  EndFor
  LCD.Update()                                              ' прорисовываем новое состояние поля
  Speaker.Play(30*@Sound, "Boo")                            ' выводим звуковой гудок об этом
  ' за каждую следующую одновременно удаляемую строку тоже увеличиваем очки
  @Count = @Count + @Uroven * (@N_Y - Nstr) * Nstr          ' увеличиваем счет - причем чем выше строка тем больше за нее очков
  DrawCount(@Count)                                         ' прорисовываем счет на поле
  EV3.SetLEDColor("ORANGE", "NORMAL")                       ' моргаем светодиодом
  Program.Delay(200)                                        ' маленькая задержка
  EV3.SetLEDColor("OFF", "NORMAL")                          ' для отображения что фигурка остановилась
EndFunction

'------------------------------------------------------------------------------------------------------------------------------------
' Отображение текущего счета на экране ЖКИ во время игры
Function DrawCount(in number CountIn)
  If CountIn >= 10000 Then                                  ' Центруем счет
    Xs = 0                                                  ' в заданном для него окошечке
  ElseIf CountIn >= 1000 Then
    Xs = 8
  ElseIf CountIn >= 100 Then
    Xs = 16
  ElseIf CountIn >= 10 Then
    Xs = 24
  Else
    XS = 32
  EndIf
  LCD.Text (1, Xs, 23, 2, CountIn)                         ' отображаем его на экране
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
' Создание новой фигуры
Function CreateFig(out number Res)
  ' Type и Direction - текущей выводимой фигуры вычисляются в функции Next(), так как эта фигура должна была отображаться на ЖКИ как следующая
  @Type = @Type_Next                      ' Задаем тип фигуры, которую выводили в поле next
  @Direct = @Direct_Next                  ' и ее ориентацию
  ' Строим фигуру по типу и повороту, т.е. вычисляем смещения dX и dY для 2,3,4 кубиков относительно 1 кубика
  GetFig(@Type, @Direct, @Xf, @Yf, @dX2, @dY2, @dX3, @dY3, @dX4, @dY4)
  @Xf = @Xf + @N_X / 2 - 1                      ' Фигуру ставим в центре в верхних строках
  ' проверяем, поместится ли создаваемая фигура на игровом поле, не попадает ли она на уже занятые клетки?
  IsBusy(@Xf, @Yf, @dX2, @dY2, @dX3, @dY3, @dX4, @dY4, Res)
  ' доработал GetFig - поэтому нет необходимости смещать фигуру вниз.
  '  If Res = 11 Or Res = 12 Or Res = 13 Then      'Если фигура выходит за верхнюю рамку игрового поля
  '    @Yf = @Yf + Math.Remainder(Res, 10)           'то смещаем ее на столько строк вниз, чтобы она вся поместилась на поле
  '    IsBusy(@Xf, @Yf, @dX2, @dY2, @dX3, @dY3, @dX4, @dY4, Res) 'Но все равно проверяем может ли она поместиться на новой позиции
  '  EndIf
  If Res = 1 Then         'Выдаем гудок в зависимости от того получилось создать фигуру или нет
    Speaker.Play(30*@Sound, "Smack")
    Draw()
  Else
    Speaker.Play(30*@Sound, "Error")
  EndIf
  Next()                                  ' Подготавливаем следующую фигуру
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
Function Move(in string Napr, out number Resulte)
  If Napr = "R" Then      'Смещаем фигуру вправо
    X = @Xf + 1
    Y = @Yf
  ElseIf Napr = "L" Then 'Смещаем фигуру влево
    X = @Xf - 1
    Y = @Yf
  ElseIf Napr = "D" Then 'Смещаем фигуру вниз
    X = @Xf
    Y = @Yf + 1
  EndIf
  LCD.StopUpdate()
  Clear()             ' Вначале в любом случае убираем фигуру со старой позиции - при ошибке прорисуем ее в старой позиции повторно
  ' проверяем можно ли переместить фигуру в новую позицию (при этом тип фигуры и ее ориентация не меняются)
  IsBusy(X, Y, @dX2, @dY2, @dX3, @dY3, @dX4, @dY4, Resulte)
  If Resulte = 1 Then
    @Xf = X              ' Перемещаем фигуру на новую
    @Yf = Y              ' позицию
    Speaker.Play(20*@Sound, "Click") '.Note(80, "C4", 200)   'Выдаем гудок что сместили нашу фигуру
  Else
    Speaker.Play(20*@Sound, "Smack")   'или не получилось сместить
  EndIf
  Draw()                ' прорисовываем фигуру в старой или новой позиции, в зависимости от проверки
  LCD.Update()
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
Function Rotate(in string Napr, out number Resulte)
  If Napr = "U" Then      'Поворачиваем фигуру вправо, то есть по часовой
    Dir = Byte.AND_((@Direct + 1), 3)
  ElseIf Napr = "E" Then  'Поворачиваем фигуру влево, то есть против часовой
    Dir = Byte.AND_((@Direct - 1), 3)
  EndIf
  GetPovorot(@Type, @Direct, Napr, dX, dY)                   ' Для новой позиции вычисляем смещение для 1-го кубика фигуры
  X = @Xf + dX
  Y = @Yf + dY
  GetFig(@Type, Dir, X1, Y1, dX_2, dY_2, dX_3, dY_3, dX_4, dY_4) ' и для 2,3,4 кубиков
  ' проверяем можно ли переместить фигуру в новую позицию
  LCD.StopUpdate()          'чтобы не мерцало - блокируем вывод на ЖКИ - до перерисовки фигуры
  Clear()                   ' перед проверкой убираем фигуру со старой позиции - так как в поле клетки ей заняты, то их надо освободить
  IsBusy(X, Y, dX_2, dY_2, dX_3, dY_3, dX_4, dY_4, Resulte)
  If Resulte = 1 Then
    @Xf = X              ' размещаем фигуру на новой позиции
    @Yf = Y
    @Direct = Dir               '
    @dX2 = dX_2
    @dY2 = dY_2
    @dX3 = dX_3
    @dY3 = dY_3
    @dX4 = dX_4
    @dY4 = dY_4
    Speaker.Play(20*@Sound, "Click") '.Note(80, "C4", 200)   'Выдаем гудок что сместили нашу фигуру
  Else
    'Speaker.Play(20*@Sound, "Smack")   'или не получилось сместить
  EndIf
  Draw()                    ' Прорисовываем фигуру или после поворота в новой позиции, или если поворот невозможен в старой
  LCD.Update()
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
' Проверка возможности поместить фигуру в задаваемую позицию X:Y (для первого кубика, для остальных смещение dXn:dYn, где n = 2,3,4)
' При выходе за границы игрового поля возвращаем Res - двухзначный код ошибки - старшая цифра кодирует границу, за которую вышли:
' 1 - верхняя граница Y < 0, 2 - левая граница X < 0, 3 - правая граница X > N_X, 4 - нижняя граница - Y > N_Y,
' младшая цифра кода кодирует число клеток насколько вышли за границу (от 1 до 3)
' Также проверяем заняты ли клетки игрового поля куда мы хотим поместить фигуру - если заняты - возвращаем Res = 0,
' Если позиция свободна - возвращаем Res = 1
Function IsBusy(in number X,in number Y,in number d_X2,in number d_Y2,in number d_X3,in number d_Y3,in number d_X4,in number d_Y4,out number Res)
  Res = 0
  ' Вначале проверяем не выходит ли кубики фигуры за пределы игрового поля
  ' проверяем на выход за верхнюю границу
  d1 = 0
  d2 = 0
  d3 = 0
  d4 = 0
  If Y < 0 Then
    Res = 10
    d1 = 0-Y
  EndIf
  If Y + d_Y2 < 0 Then
    Res = 10
    d2 = 0-Y-d_Y2
  EndIf
  If Y + d_Y3 < 0 Then
    Res = 10
    d3 = 0-Y-d_Y3
  EndIf
  If Y + d_Y4 < 0 Then
    Res = 10
    d4 = 0-Y-d_Y4
  EndIf
  If Res = 10 Then
    d = Math.Max(Math.Max(d1, d2), Math.Max(d3, d4))
    Res = Res + d               ' формируем код ошибки
    Goto End_IsBusy
  EndIf
  Res = 0
  ' теперь проверяем на выход за левую границу
  d1 = 0
  d2 = 0
  d3 = 0
  d4 = 0
  If X < 0 Then
    Res = 20
    d1 = 0-X
  EndIf
  If X + d_X2 < 0 Then
    Res = 20
    d2 = 0-X-d_X2
  EndIf
  If X + d_X3 < 0 Then
    Res = 20
    d3 = 0-X-d_X3
  EndIf
  If X + d_X4 < 0 Then
    Res = 20
    d4 = 0-X-d_X4
  EndIf
  If Res = 20 Then
    d = Math.Max(Math.Max(d1, d2), Math.Max(d3, d4))
    Res = Res + d               ' формируем код ошибки
    Goto End_IsBusy
  EndIf
  ' теперь проверяем на выход за правую границу
  d1 = 0
  d2 = 0
  d3 = 0
  d4 = 0
  If X >= @N_X Then
    Res = 30
    d1 = @N_X-X+1
  EndIf
  If X + d_X2 >= @N_X Then
    Res = 30
    d2 = @N_X-X-d_X2+1
  EndIf
  If X + d_X3 >= @N_X Then
    Res = 30
    d3 = @N_X-X-d_X3+1
  EndIf
  If X + d_X4 >= @N_X Then
    Res = 30
    d4 = @N_X-X-d_X4+1
  EndIf
  If Res = 30 Then
    d = Math.Max(Math.Max(d1, d2), Math.Max(d3, d4))
    Res = Res + d               ' формируем код ошибки
    Goto End_IsBusy
  EndIf
  ' заканчиваем проверкой на выход за нижнюю границу
  d1 = 0
  d2 = 0
  d3 = 0
  d4 = 0
  If Y >= @N_Y Then
    Res = 40
    d1 = @N_Y-Y+1
  EndIf
  If Y + d_Y2 >= @N_Y Then
    Res = 40
    d2 = @N_Y-Y-d_Y2+1
  EndIf
  If Y + d_Y3 >= @N_Y Then
    Res = 40
    d3 = @N_Y-Y-d_Y3+1
  EndIf
  If Y + d_Y4 >= @N_Y Then
    Res = 40
    d4 = @N_Y-Y-d_Y4+1
  EndIf
  If Res = 40 Then
    d = Math.Max(Math.Max(d1, d2), Math.Max(d3, d4))
    Res = Res + d               ' формируем код ошибки
    Goto End_IsBusy
  EndIf
  ' Если границы игрового поля не нарушены, то надо проверить не заняты ли клетки поля кубиками от предыдущих фигур
  Res = 1                 ' Задаем признак совбодной позиции
  'P1 = Pole[Yf * N_X + Xf]
  'P1 = Pole[0]
  If @Pole[Y*@N_X+X] = 1 Or @Pole[(Y+d_Y2)*@N_X+(X+d_X2)] = 1 Or @Pole[(Y+d_Y3)*@N_X+(X+d_X3)] = 1 Or @Pole[(Y+d_Y4)*@N_X+(X+d_X4)] = 1 Then
    Res = 0               ' Увы - позиция для фигуры занята
  EndIf
  End_IsBusy:
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
' По типу и ориентации фигуры вычисляем начальные координаты для 1-го кубика (от 0 до 3) и смещения для 2,3,4-го кубика фигуры относительно первого
Function GetFig(in number T, in number D, out number Xn, out number Yn, out number dX2, out number dY2, out number dX3, out number dY3, out number dX4, out number dY4)
  If     T = 1 And D = 0 Then  ' 1:0
    Xn  =   0
    Yn  =   2
    dX2 =   1
    dY2 =   0
    dX3 =   2
    dY3 =   0
    dX4 =   3
    dY4 =   0
  ElseIf T = 1 And D = 1 Then  ' 1:1
    Xn  =   1
    Yn  =   0
    dX2 =   0
    dY2 =   1
    dX3 =   0
    dY3 =   2
    dX4 =   0
    dY4 =   3
  ElseIf T = 1 And D = 2 Then  ' 1:2
    Xn  =   3
    Yn  =   2
    dX2 =  -1
    dY2 =   0
    dX3 =  -2
    dY3 =   0
    dX4 =  -3
    dY4 =   0
  ElseIf T = 1 And D = 3 Then  ' 1:3
    Xn  =   2
    Yn  =   3
    dX2 =   0
    dY2 =  -1
    dX3 =   0
    dY3 =  -2
    dX4 =   0
    dY4 =  -3
  ElseIf T = 2 And D = 0 Then  ' 2:0
    Xn  =   0
    Yn  =   1
    dX2 =   1
    dY2 =   0
    dX3 =   2
    dY3 =   0
    dX4 =   0
    dY4 =   1
  ElseIf T = 2 And D = 1 Then  ' 2:1
    Xn  =   1
    Yn  =   0
    dX2 =   0
    dY2 =   1
    dX3 =   0
    dY3 =   2
    dX4 =  -1
    dY4 =   0
  ElseIf T = 2 And D = 2 Then  ' 2:2
    Xn  =   2
    Yn  =   2
    dX2 =  -1
    dY2 =   0
    dX3 =  -2
    dY3 =   0
    dX4 =   0
    dY4 =  -1
  ElseIf T = 2 And D = 3 Then  ' 2:3
    Xn  =   1
    Yn  =   2
    dX2 =   0
    dY2 =  -1
    dX3 =   0
    dY3 =  -2
    dX4 =   1
    dY4 =   0
  ElseIf T = 3 And D = 0 Then  ' 3:0
    Xn  =   0
    Yn  =   1
    dX2 =   1
    dY2 =   0
    dX3 =   2
    dY3 =   0
    dX4 =   1
    dY4 =   1
  ElseIf T = 3 And D = 1 Then  ' 3:1
    Xn  =   1
    Yn  =   0
    dX2 =   0
    dY2 =   1
    dX3 =   0
    dY3 =   2
    dX4 =  -1
    dY4 =   1
  ElseIf T = 3 And D = 2 Then  ' 3:2
    Xn  =   2
    Yn  =   2
    dX2 =  -1
    dY2 =   0
    dX3 =  -2
    dY3 =   0
    dX4 =  -1
    dY4 =  -1
  ElseIf T = 3 And D = 3 Then  ' 3:3
    Xn  =   1
    Yn  =   2
    dX2 =   0
    dY2 =  -1
    dX3 =   0
    dY3 =  -2
    dX4 =   1
    dY4 =  -1
  ElseIf T = 4 And D = 0 Then  ' 4:0
    Xn  =   0
    Yn  =   1
    dX2 =   1
    dY2 =   0
    dX3 =   2
    dY3 =   0
    dX4 =   2
    dY4 =   1
  ElseIf T = 4 And D = 1 Then  ' 4:1
    Xn  =   1
    Yn  =   0
    dX2 =   0
    dY2 =   1
    dX3 =   0
    dY3 =   2
    dX4 =  -1
    dY4 =   2
  ElseIf T = 4 And D = 2 Then  ' 4:2
    Xn  =   2
    Yn  =   2
    dX2 =  -1
    dY2 =   0
    dX3 =  -2
    dY3 =   0
    dX4 =  -2
    dY4 =  -1
  ElseIf T = 4 And D = 3 Then  ' 4:3
    Xn  =   1
    Yn  =   2
    dX2 =   0
    dY2 =  -1
    dX3 =   0
    dY3 =  -2
    dX4 =   1
    dY4 =  -2
  ElseIf T = 5 And D = 0 Then  ' 5:0
    Xn  =   1
    Yn  =   1
    dX2 =   1
    dY2 =   0
    dX3 =   1
    dY3 =   1
    dX4 =   0
    dY4 =   1
  ElseIf T = 5 And D = 1 Then  ' 5:1
    Xn  =   2
    Yn  =   1
    dX2 =   0
    dY2 =   1
    dX3 =  -1
    dY3 =   1
    dX4 =  -1
    dY4 =   0
  ElseIf T = 5 And D = 2 Then  ' 5:2
    Xn  =   2
    Yn  =   2
    dX2 =  -1
    dY2 =   0
    dX3 =  -1
    dY3 =  -1
    dX4 =   0
    dY4 =  -1
  ElseIf T = 5 And D = 3 Then  ' 5:3
    Xn  =   1
    Yn  =   2
    dX2 =   0
    dY2 =  -1
    dX3 =   1
    dY3 =  -1
    dX4 =   1
    dY4 =   0
  ElseIf T = 6 And D = 0 Then  ' 6:0
    Xn  =   0
    Yn  =   1
    dX2 =   1
    dY2 =   0
    dX3 =   1
    dY3 =   1
    dX4 =   2
    dY4 =   1
  ElseIf T = 6 And D = 1 Then  ' 6:1
    Xn  =   0
    Yn  =   1
    dX2 =   0
    dY2 =   1
    dX3 =  -1
    dY3 =   1
    dX4 =  -1
    dY4 =   2
  ElseIf T = 6 And D = 2 Then  ' 6:2
    Xn  =   1
    Yn  =   0
    dX2 =  -1
    dY2 =   0
    dX3 =  -1
    dY3 =  -1
    dX4 =  -2
    dY4 =  -1
  ElseIf T = 6 And D = 3 Then  ' 6:3
    Xn  =   2
    Yn  =   2
    dX2 =   0
    dY2 =  -1
    dX3 =   1
    dY3 =  -1
    dX4 =   1
    dY4 =  -2
  ElseIf T = 7 And D = 0 Then  ' 7:0
    Xn  =   0
    Yn  =   2
    dX2 =   1
    dY2 =   0
    dX3 =   1
    dY3 =  -1
    dX4 =   2
    dY4 =  -1
  ElseIf T = 7 And D = 1 Then  ' 7:1
    Xn  =   0
    Yn  =   0
    dX2 =   0
    dY2 =   1
    dX3 =   1
    dY3 =   1
    dX4 =   1
    dY4 =   2
  ElseIf T = 7 And D = 2 Then  ' 7:2
    Xn  =   2
    Yn  =   1
    dX2 =  -1
    dY2 =   0
    dX3 =  -1
    dY3 =   1
    dX4 =  -2
    dY4 =   1
  ElseIf T = 7 And D = 3 Then  ' 7:3
    Xn  =   1
    Yn  =   2
    dX2 =   0
    dY2 =  -1
    dX3 =  -1
    dY3 =  -1
    dX4 =  -1
    dY4 =  -2
  EndIf
EndFunction
'------------------------------------------------------------------------------------------------------------------------------------
' Вычисляем смещения для 1-го кубика фигуры при повороте
Function GetPovorot(in number T, in number D, in string Nap, out number dX, out number dY)
  If     Nap = "U" Then               ' поворачиваем по часовой стрелке
    If     T = 1 And D = 0 Then  ' 1:0
      dX =  1
      dY = -2
    ElseIf T = 1 And D = 1 Then  ' 1:1
      dX =  2
      dY =  2
    ElseIf T = 1 And D = 2 Then  ' 1:2
      dX = -1
      dY =  1
    ElseIf T = 1 And D = 3 Then  ' 1:3
      dX = -2
      dY = -1
    ElseIf T = 2 And D = 0 Then  ' 2:0
      dX =  1
      dY = -1
    ElseIf T = 2 And D = 1 Then  ' 2:1
      dX =  1
      dY =  2
    ElseIf T = 2 And D = 2 Then  ' 2:2
      dX = -1
      dY =  0
    ElseIf T = 2 And D = 3 Then  ' 2:3
      dX = -1
      dY = -1
    ElseIf T = 3 And D = 0 Then  ' 3:0
      dX =  1
      dY = -1
    ElseIf T = 3 And D = 1 Then  ' 3:1
      dX =  1
      dY =  2
    ElseIf T = 3 And D = 2 Then  ' 3:2
      dX = -1
      dY =  0
    ElseIf T = 3 And D = 3 Then  ' 3:3
      dX = -1
      dY = -1
    ElseIf T = 4 And D = 0 Then  ' 4:0
      dX =  1
      dY = -1
    ElseIf T = 4 And D = 1 Then  ' 4:1
      dX =  1
      dY =  2
    ElseIf T = 4 And D = 2 Then  ' 4:2
      dX = -1
      dY =  0
    ElseIf T = 4 And D = 3 Then  ' 4:3
      dX = -1
      dY = -1
    ElseIf T = 5 And D = 0 Then  ' 5:0
      dX =  1
      dY =  0
    ElseIf T = 5 And D = 1 Then  ' 5:1
      dX =  0
      dY =  1
    ElseIf T = 5 And D = 2 Then  ' 5:2
      dX = -1
      dY =  0
    ElseIf T = 5 And D = 3 Then  ' 5:3
      dX =  0
      dY = -1
    ElseIf T = 6 And D = 0 Then  ' 6:0
      dX =  1
      dY = -1
    ElseIf T = 6 And D = 1 Then  ' 6:1
      dX =  1
      dY =  2
    ElseIf T = 6 And D = 2 Then  ' 6:2
      dX = -2
      dY =  0
    ElseIf T = 6 And D = 3 Then  ' 6:3
      dX =  0
      dY = -1
    ElseIf T = 7 And D = 0 Then  ' 7:0
      dX =  0
      dY = -2
    ElseIf T = 7 And D = 1 Then  ' 7:1
      dX =  2
      dY =  1
    ElseIf T = 7 And D = 2 Then  ' 7:2
      dX =  0
      dY =  1
    ElseIf T = 7 And D = 3 Then  ' 7:3
      dX = -1
      dY =  0
    EndIf
  ElseIf Nap = "E" Then               ' поворачиваем против часовой стрелки
    If     T = 1 And D = 0 Then  ' 1:0
      dX =  2
      dY =  1
    ElseIf T = 1 And D = 1 Then  ' 1:1
      dX = -2
      dY =  2
    ElseIf T = 1 And D = 2 Then  ' 1:2
      dX = -2
      dY = -2
    ElseIf T = 1 And D = 3 Then  ' 1:3
      dX =  1
      dY = -1
    ElseIf T = 2 And D = 0 Then  ' 2:0
      dX =  1
      dY =  1
    ElseIf T = 2 And D = 1 Then  ' 2:1
      dX = -1
      dY =  1
    ElseIf T = 2 And D = 2 Then  ' 2:2
      dX = -1
      dY = -2
    ElseIf T = 2 And D = 3 Then  ' 2:3
      dX =  1
      dY =  0
    ElseIf T = 3 And D = 0 Then  ' 3:0
      dX =  1
      dY =  1
    ElseIf T = 3 And D = 1 Then  ' 3:1
      dX = -1
      dY =  1
    ElseIf T = 3 And D = 2 Then  ' 3:2
      dX = -1
      dY = -2
    ElseIf T = 3 And D = 3 Then  ' 3:3
      dX =  1
      dY =  0
    ElseIf T = 4 And D = 0 Then  ' 4:0
      dX =  2
      dY =  1
    ElseIf T = 4 And D = 1 Then  ' 4:1
      dX = -2
      dY =  1
    ElseIf T = 4 And D = 2 Then  ' 4:2
      dX = -1
      dY = -2
    ElseIf T = 4 And D = 3 Then  ' 4:3
      dX =  1
      dY =  0
    ElseIf T = 5 And D = 0 Then  ' 5:0
      dX =  0
      dY =  1
    ElseIf T = 5 And D = 1 Then  ' 5:1
      dX = -1
      dY =  0
    ElseIf T = 5 And D = 2 Then  ' 5:2
      dX =  0
      dY = -1
    ElseIf T = 5 And D = 3 Then  ' 5:3
      dX =  1
      dY =  0
    ElseIf T = 6 And D = 0 Then  ' 6:0
      dX =  1
      dY =  1
    ElseIf T = 6 And D = 1 Then  ' 6:1
      dX = -1
      dY =  1
    ElseIf T = 6 And D = 2 Then  ' 6:2
      dX = -1
      dY = -2
    ElseIf T = 6 And D = 3 Then  ' 6:3
      dX =  2
      dY =  0
    ElseIf T = 7 And D = 0 Then  ' 7:0
      dX =  1
      dY =  0
    ElseIf T = 7 And D = 1 Then  ' 7:1
      dX =  0
      dY =  2
    ElseIf T = 7 And D = 2 Then  ' 7:2
      dX = -2
      dY = -1
    ElseIf T = 7 And D = 3 Then  ' 7:3
      dX =  1
      dY = -1
    EndIf
  EndIf
EndFunction

'╔═══╦═══════════════════╦═══════════════════╦═══════════════════╦═══════════════════╦═══════════════════╦═══════════════════╦═══════════════════╗
'║   ║  1 - ███████      ║   2 - ██████      ║   3 - ██████      ║   4 - ██████      ║   5 - ████        ║   6 - ████        ║   7 -   ████      ║
'║   ║                   ║       ██          ║         ██        ║           ██      ║       ████        ║         ████      ║       ████        ║
'╠═══╬════╤════╤════╤════╬════╤════╤════╤════╬════╤════╤════╤════╬════╤════╤════╤════╬════╤════╤════╤════╬════╤════╤════╤════╬════╤════╤════╤════╣
'║   ║ 1:0│ 1:1│ 1:2│ 1:3║ 2:0│ 2:1│ 2:2│ 2:3║ 3:0│ 3:1│ 3:2│ 3:3║ 4:0│ 4:1│ 4:2│ 4:3║ 5:0│ 5:1│ 5:2│ 5:3║ 6:0│ 6:1│ 6:2│ 6:3║ 7:0│ 7:1│ 7:2│ 7:3║
'╠═══╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╣
'║   ║    │ 1  │    │  4 ║    │41  │    │ 3  ║    │ 1  │    │ 3  ║    │ 1  │    │ 34 ║    │    │    │    ║    │ 1  │    │ 4  ║    │1   │    │4   ║
'║   ║    │ 2  │    │  3 ║123 │ 2  │  4 │ 2  ║123 │42  │ 4  │ 24 ║123 │ 2  │4   │ 2  ║ 12 │ 41 │ 34 │ 23 ║12  │32  │43  │23  ║ 34 │23  │ 21 │32  ║
'║   ║1234│ 3  │4321│  2 ║4   │ 3  │321 │ 14 ║ 4  │ 3  │321 │ 1  ║  4 │43  │321 │ 1  ║ 43 │ 32 │ 21 │ 14 ║ 34 │4   │ 21 │1   ║12  │ 4  │43  │ 1  ║
'║   ║    │ 4  │    │  1 ║    │    │    │    ║    │    │    │    ║    │    │    │    ║    │    │    │    ║    │    │    │    ║    │    │    │    ║
'╠═══╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╣
'║dXr║ +1 │ +2 │ -1 │ -2 ║ +1 │ +1 │ -1 │ -1 ║ +1 │ +1 │ -1 │ -1 ║ +1 │ +1 │ -1 │ -1 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +1 │ -2 │  0 ║ +0 │ +2 │ +0 │ -1 ║
'║dYr║ -2 │ +2 │ +1 │ -1 ║ -1 │ +2 │ +0 │ -1 ║ -1 │ +2 │ +0 │ -1 ║ -1 │ +2 │ +0 │ -1 ║ +0 │ +1 │ +0 │ -1 ║ -1 │ +2 │ +0 │ -1 ║ -2 │ +1 │ +1 │ +0 ║
'╟───╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╢
'║dXl║ +2 │ -2 │ -2 │ +1 ║ +1 │ -1 │ -1 │ +1 ║ +1 │ -1 │ -1 │ +1 ║ +2 │ -2 │ -1 │ +1 ║ +0 │ -1 │ +0 │ +1 ║ +1 │ -1 │ -1 │ +2 ║ +1 │ +0 │ -2 │ +1 ║
'║dYl║ +1 │ +2 │ -2 │ -1 ║ +1 │ +1 │ -2 │ +0 ║ +1 │ +1 │ -2 │ +0 ║ +1 │ +1 │ -2 │ +0 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +1 │ -2 │ +0 ║ +0 │ +2 │ -1 │ -1 ║
'╠═══╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╣
'║dX2║ +1 │ +0 │ -1 │ +0 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +0 │ -1 │ +0 ║
'║dY2║ +0 │ +1 │ +0 │ -1 ║ +0 │ +1 │ +0 │ -1 ║ +0 │ +1 │ +0 │ -1 ║ +0 │ +1 │ +0 │ -1 ║ +0 │ +1 │ +0 │ -1 ║ +0 │ +1 │ +0 │ -1 ║ +0 │ +1 │ +0 │ -1 ║
'╟───╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╢
'║dX3║ +2 │ +0 │ -2 │ +0 ║ +2 │ +0 │ -2 │ +0 ║ +2 │ +0 │ -2 │ +0 ║ +2 │ +0 │ -2 │ +0 ║ +1 │ -1 │ -1 │ +1 ║ +1 │ -1 │ -1 │ +1 ║ +1 │ +1 │ -1 │ -1 ║
'║dY3║ +0 │ +2 │ +0 │ -2 ║ +0 │ +2 │ +0 │ -2 ║ +0 │ +2 │ +0 │ -2 ║ +0 │ +2 │ +0 │ -2 ║ +1 │ +1 │ -1 │ -1 ║ +1 │ +1 │ -1 │ -1 ║ -1 │ +1 │ +1 │ -1 ║
'╟───╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╫────┼────┼────┼────╢
'║dX4║ +3 │ +0 │ -3 │ +0 ║ +0 │ -1 │ +0 │ +1 ║ +1 │ -1 │ -1 │ +1 ║ +2 │ -1 │ -2 │ +1 ║ +0 │ -1 │ +0 │ +1 ║ +2 │ -1 │ -2 │ +1 ║ +2 │ +1 │ -2 │ -1 ║
'║dY4║ +0 │ +3 │ +0 │ -3 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +1 │ -1 │ -1 ║ +1 │ +2 │ -1 │ -2 ║ +1 │ +0 │ -1 │ +0 ║ +1 │ +2 │ -1 │ -2 ║ -1 │ +2 │ +1 │ -2 ║
'╠═══╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╬════╪════╪════╪════╣
'║ Xn║  0 │  1 │  3 │  2 ║  0 │  1 │  2 │  1 ║  0 │  1 │  2 │  1 ║  0 │  1 │  2 │  1 ║  1 │  2 │  2 │  1 ║  0 │  1 │  2 │  0 ║  0 │  0 │  2 │  1 ║
'║ Yn║  2 │  0 │  2 │  3 ║  1 │  0 │  2 │  2 ║  1 │  0 │  2 │  2 ║  1 │  0 │  2 │  2 ║  1 │  1 │  2 │  2 ║  1 │  0 │  2 │  2 ║  2 │  0 │  1 │  2 ║
'╚═══╩════╧════╧════╧════╩════╧════╧════╧════╩════╧════╧════╧════╩════╧════╧════╧════╩════╧════╧════╧════╩════╧════╧════╧════╩════╧════╧════╧════╝
'==================================================================================================================================================


